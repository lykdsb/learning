- [基本概念](#基本概念)
  - [同步和异步](#同步和异步)
  - [并发和并行](#并发和并行)
  - [临界区](#临界区)
  - [阻塞和非阻塞](#阻塞和非阻塞)
  - [死锁、活锁、饥饿](#死锁活锁饥饿)
  - [并发级别](#并发级别)
    - [阻塞](#阻塞)
    - [无饥饿](#无饥饿)
    - [无障碍](#无障碍)
    - [无锁](#无锁)
    - [无等待](#无等待)
  - [原子性、可见行、有序性](#原子性可见行有序性)
    - [原子性](#原子性)
    - [可见性](#可见性)
    - [有序性](#有序性)
# 基本概念

## 同步和异步

同步和异步一般用于形容一次方法调用

* 同步方法一旦开始，那么调用者必须等待方法返回之后才能够进行进行后续的行为
* 异步方法开始后会立即进行返回，调用者可以进行之后的操作。而调用的方法会在另一个线程中执行

## 并发和并行

并发和并行都是**多个任务同时进行**，但是偏重点不一样：
* 并发：**偏重于多个任务交替执行，多个任务之间是可以串行的**
* 并行：**是真正的同时执行**

对于单核系统来说，多进程或者多线程一定是并发的不可能是并行的

并行只可能发生在多核系统中

## 临界区
临界区表示一种公共资源或者说共享数据，可以被多个线程使用，但是同时只能有一个线程进行使用。

## 阻塞和非阻塞

阻塞和非阻塞用来表示线程之间的相互干扰

* 阻塞：线程如果占用率临界区资源，那么其他线程必须等待，等待导致线程挂起称为**阻塞**
* 非阻塞：没有线程能够妨碍其他线程执行，所有的线程都会尝试不断向前执行

## 死锁、活锁、饥饿

死锁是指两个或者两个以上的线程因为争夺资源而进入相互等待的状态，如果发生死锁不加以外部作用是不能解除的

死锁发生有四个条件

1. 互斥：对于资源的访问是互斥的
2. 请求与保持：持有资源的被请求资源后会继续保持
3. 不可剥夺：持有的资源不可被其他线程剥夺
4. 环路等待 ：等待形成环路


饥饿：一个或者多个线程由于优先级较低导致一直无法执行

活锁：两个线程都可以使用资源，但是两个线程相互谦让导致谁都无法使用资源

## 并发级别
并发级别可以分为以下几种
* 阻塞
* 无饥饿
* 无障碍
* 无锁
* 无等待

### 阻塞

其他线程释放资源之前，当前线程无法继续执行

使用synchronized或者可重入锁的时候就是**阻塞**的级别

### 无饥饿

使用公平的锁的时候，不管来的线程的优先级怎么样都需要进行排队，这样就不会发生饥饿的问题

### 无障碍

所有线程都可以同时进入临界区，如果发生冲突的话，会立即对于自己做出的修改进行回滚来确保数据的安全性

可以说这种同步的方式是一种**乐观**的策略

### 无锁

无锁与无障碍类似，但是无锁能够保证至少有一个线程能够执行下去，在修改中“胜出”

但是其存在一个问题，可能有一直在临界区中竞争失败的线程，会不断进行尝试导致线程停滞不前
```java
while(!atomicVar.compareAndSet(localVar,localVar+1))
{
    localVar=atomicVar.get();
}
```

### 无等待
要求所有线程必须在有限步内完成，这样不会导致长时间的等待

比较典型的设计是RCU：
* 读线程的时候是无等待的，因为其不会引起任何冲突
* 写数据时先取得原始数据的副本。接着只修改副本数据，之后在合适的时机将副本中的数据写回

## 原子性、可见行、有序性

### 原子性

原子性表示一个操作是**不可中断的**，即便是多个线程一起执行的时候也不会别其他线程干扰

对于一个静态全局变量，两个线程对其赋值，最终其值要么是A线程赋的，要么是B线程赋的，不存在相互作用

但是对于long型变量不会是这样（32位虚拟机）
```java
new Thread(new changeT(111L)).start();
new Thread(new changeT(222L)).start();
new Thread(new ReadT()).start();
```
如果这样去读的话，结果是
```
4294966962
```
这是因为long的读写都不是原子性的（二进制码发生串位）

### 可见性
可见性指的是如果一个线程修改一个变量的值，其他线程未必知道这个值发生变化
主要有以下的原因
* 缓存优化
* 指令重排
* 编辑器优化

### 有序性
有序性在并发的时候指的是指令的执行未必是按顺序的
比如
```java
public void writer()
{
    a=1;
    flag=true;
}
public void reader()
{
    if(flag)
    {
        int i=a+1;
        ...
    }
}
```
如果线程a调用writer，线程b调用reader可能实际执行起来就成了

writer先调用flag=true，然后还没执行a=1,就进入了reader里面的`int i=a+1`,导致完全不一样的结果