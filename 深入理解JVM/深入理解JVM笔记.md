- [java内存区域](#java内存区域)
  - [概述](#概述)
  - [运行时数据区域](#运行时数据区域)
    - [程序计数器](#程序计数器)
    - [java虚拟机栈](#java虚拟机栈)
    - [本地方法栈](#本地方法栈)
    - [堆](#堆)
    - [方法区](#方法区)
    - [运行时常量池](#运行时常量池)
  - [对象访问](#对象访问)
- [垃圾回收](#垃圾回收)
  - [判断对象可以回收](#判断对象可以回收)
    - [引用计数法](#引用计数法)
    - [根搜索方法](#根搜索方法)
  - [引用](#引用)

# java内存区域

## 概述
对于java来说，由于有JVM的存在，因此不需要关注内存泄漏等问题，但是如果一旦出现问题，如果不知道JVM相关只是是很麻烦的

## 运行时数据区域
JVM会在**运行java程序时**将其管理的内存划分为几个不同的数据区域

### 程序计数器
程序计数器可以看做当前线程所执行的字节码的**行号指示器**  
字节码通过改变计数器的值来选择下一条需要执行的指令

java的多线程是通过线程轮流切换并且分配处理器执行时间的方式来实现的，**为了线程切换后能够恢复到正确的执行位置**，每个线程都有一个独立的程序计数器

⚠️：这个内存区域是唯一一个在java虚拟机中没有规定`OutofMemoryError`情况的区域

### java虚拟机栈
java虚拟机栈也是线程私有的，**生命周期与线程线程相同**  
每个方法被执行的时候都有一个栈帧，存储变量表、方法出口等信息

这个内存区域有两种异常状况  
* StackOverflowErroe
* OutOfMemoryError

### 本地方法栈
与虚拟机栈大致相同，但是是为了本地方法进行服务的

### 堆
java堆是最大的一块内存区域，是线程共享的，在**虚拟机启动**的时候创建，目的就是用来存放对象实例，也是垃圾回收的主要工作区域  
⚠️：java堆可以处于物理上不连续的内存空间中，只需要逻辑上是连续的就行了

### 方法区
方法区也是线程共享的内存区域，用于存储已经被虚拟机加载的类信息、常量、静态变量等数据

### 运行时常量池
常量池是方法区的一部分。Class文件中有一部分就是常量池，用于存储编译时产生的字面量和符号引用，在类加载后存放到方法去的运行时常量池中

## 对象访问
最简单的代码
```java
Object obj = new Object();
```
`Object obj`会映射到java栈的本地变量表中，作为一个reference类型的数据出现  
`new Object()`会创建一个新的对象，在java堆中分配一个结构化的内存空间  
对象的类型、父类等信息则存储在方法区中  

# 垃圾回收
## 判断对象可以回收
### 引用计数法
比较常见的一种方式是引用计数法，这种方法是给对象添加一个计数器，每次被引用之后就加一，相反则减一，如果对象的引用计数器为0则可以进行回收  
⚠️：但是这种方式有一个很大的问题，即可能出现循环引用的问题，因此一般不会使用这种方式

### 根搜索方法
通过GCRoot进行向下的搜索，如果不能和GCRoot建立链接的话就说明这个对象是可以进行回收的  
可以被认为是GCRoot的对象有下面几种  
* 虚拟机栈中的引用变量
* 方法区中的类静态属性引用的变量
* 方法区中的常量引用的变量
* 本地方法栈中引用的变量

这些对象可以作为GCRoot的主要原因是，**垃圾回收主要发生在堆上，因此选择不是堆的一些内存区域中的变量作为GCRoot有较高可靠性**

## 引用
引用一般表示存储另一个变量起始地址的对象  
java中有四种引用  
* 强引用：只要这个引用还在就永远不会被回收掉
* 软引用：系统将要发生溢出前，会进行软引用的回收
* 弱引用：只能生存到下一次垃圾回收之前
* 虚引用：完全不影响对象生存

